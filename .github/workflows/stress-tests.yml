
name: Stress Tests

on:
  push:
    branches:
      - main # Or your primary branch name
  pull_request:
    types: [opened, synchronize]
    branches:
      - main # Or your primary branch name
  workflow_dispatch: # Retain manual triggering

concurrency:
  group: |
    ${{ github.workflow }}-${{ github.workflow_ref }}-${{
      github.event_name == 'pull_request' 
      && github.event.pull_request.number 
      || github.ref_name }}
  cancel-in-progress: true

env:
  SIMULATOR_NUM_MESSAGES_CI: "1000" # Fast stress test message count for CI execution
  MAX_ALLOWED_TIME_MS: "120000" # 2 minutes timeout for processing 1K messages (CI-optimized)

jobs:
  run-stress-tests:
    name: Run Flink.NET Stress Tests
    runs-on: ubuntu-latest

    defaults:
      run:
        shell: pwsh

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure Docker is running
        run: docker info

      - name: Set up .NET 8.0
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Install .NET Aspire Workload
        run: dotnet workload install aspire

      - name: Restore .NET Workloads for Solutions
        run: |
          dotnet workload restore FlinkDotNet/FlinkDotNet.sln
          dotnet workload restore FlinkDotNetAspire/FlinkDotNetAspire.sln
          dotnet workload restore FlinkDotNet.WebUI/FlinkDotNet.WebUI.sln

      - name: Build Solutions (including Verifier)
        run: |
          echo "Building FlinkDotNet solution (dependency)..."
          Push-Location FlinkDotNet
          dotnet build FlinkDotNet.sln --configuration Release
          Pop-Location
          
          echo "Building FlinkDotNetAspire solution..."
          Push-Location FlinkDotNetAspire
          dotnet build FlinkDotNetAspire.sln --configuration Release
          Pop-Location

      - name: Start Aspire AppHost
        run: |
          $env:SIMULATOR_NUM_MESSAGES='${{ env.SIMULATOR_NUM_MESSAGES_CI }}'
          $env:ASPIRE_ALLOW_UNSECURED_TRANSPORT='true'
          
          # Create log files
          $outLogPath = "apphost.out.log"
          $errLogPath = "apphost.err.log"
          
          Write-Host "Starting AppHost with output logging to $outLogPath and $errLogPath"
          
          # Use Start-Process with file redirection
          $processArgs = @(
            'run',
            '--no-build',
            '--configuration', 'Release',
            '--project', 'FlinkDotNetAspire/FlinkDotNetAspire.AppHost.AppHost/FlinkDotNetAspire.AppHost.AppHost.csproj'
          )
          
          # Start the process with output redirection using Start-Process
          $proc = Start-Process -FilePath 'dotnet' -ArgumentList $processArgs -RedirectStandardOutput $outLogPath -RedirectStandardError $errLogPath -NoNewWindow -PassThru
          $proc.Id | Out-File apphost.pid -Encoding utf8
          
          Write-Host "Started AppHost with PID: $($proc.Id)"
          
          # Start background jobs to tail the log files and display content in real-time
          $outputJob = Start-Job -ScriptBlock {
            param($logPath)
            $lastSize = 0
            $attempts = 0
            $maxAttempts = 600  # 10 minutes of checking
            
            Write-Host "[OUTPUT MONITOR] Starting to monitor $logPath"
            
            while ($attempts -lt $maxAttempts) {
              try {
                if (Test-Path $logPath) {
                  $currentSize = (Get-Item $logPath).Length
                  if ($currentSize -gt $lastSize) {
                    # Read new content
                    $newContent = Get-Content $logPath -Tail ($currentSize - $lastSize) -Encoding utf8 -ErrorAction SilentlyContinue
                    if ($newContent) {
                      foreach ($line in $newContent) {
                        if ($line -and $line.Trim()) {
                          # Highlight FlinkJobSimulator logs for easier identification
                          if ($line -match "FlinkJobSimulator|FLINKJOBSIMULATOR|STEP \d+") {
                            Write-Host "[APPHOST-OUT] *** FLINK: $line" -ForegroundColor Yellow
                          } else {
                            Write-Host "[APPHOST-OUT] $line"
                          }
                        }
                      }
                    }
                    $lastSize = $currentSize
                  }
                }
                Start-Sleep -Seconds 1
                $attempts++
              } catch {
                Write-Host "[OUTPUT MONITOR ERROR] $_"
                Start-Sleep -Seconds 1
                $attempts++
              }
            }
            Write-Host "[OUTPUT MONITOR] Finished monitoring $logPath"
          } -ArgumentList $outLogPath
          
          $errorJob = Start-Job -ScriptBlock {
            param($logPath)
            $lastSize = 0
            $attempts = 0
            $maxAttempts = 600  # 10 minutes of checking
            
            Write-Host "[ERROR MONITOR] Starting to monitor $logPath"
            
            while ($attempts -lt $maxAttempts) {
              try {
                if (Test-Path $logPath) {
                  $currentSize = (Get-Item $logPath).Length
                  if ($currentSize -gt $lastSize) {
                    # Read new content  
                    $newContent = Get-Content $logPath -Tail ($currentSize - $lastSize) -Encoding utf8 -ErrorAction SilentlyContinue
                    if ($newContent) {
                      foreach ($line in $newContent) {
                        if ($line -and $line.Trim()) {
                          # Highlight FlinkJobSimulator errors for easier identification
                          if ($line -match "FlinkJobSimulator|FLINKJOBSIMULATOR|STEP \d+") {
                            Write-Host "[APPHOST-ERR] *** FLINK ERROR: $line" -ForegroundColor Red
                          } else {
                            Write-Host "[APPHOST-ERR] $line"
                          }
                        }
                      }
                    }
                    $lastSize = $currentSize
                  }
                }
                Start-Sleep -Seconds 1
                $attempts++
              } catch {
                Write-Host "[ERROR MONITOR ERROR] $_"
                Start-Sleep -Seconds 1
                $attempts++
              }
            }
            Write-Host "[ERROR MONITOR] Finished monitoring $logPath"
          } -ArgumentList $errLogPath
          
          $outputJob.Id | Out-File apphost.output.job -Encoding utf8
          $errorJob.Id | Out-File apphost.error.job -Encoding utf8
          
          Write-Host "Background monitor jobs started - OutputJob: $($outputJob.Id), ErrorJob: $($errorJob.Id)"
          Write-Host "AppHost started, waiting 45 seconds for Redis/Kafka container initialization and Aspire service bindings..."
          
          # Increased startup time for Aspire service binding setup
          Start-Sleep -Seconds 45
          
          # Add container diagnostics
          Write-Host "`n=== Container Diagnostics ==="
          Write-Host "Checking for Redis/Kafka container processes..."
          docker ps --format "table {{.ID}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}" | Write-Host

      - name: Discover Aspire Container Ports
        run: |
          Write-Host "Discovering actual Aspire container ports after AppHost startup..."
          & ./scripts/discover-aspire-ports.ps1
          
          Write-Host "Current environment variables after discovery:"
          Write-Host "DOTNET_REDIS_URL: $env:DOTNET_REDIS_URL"
          Write-Host "DOTNET_KAFKA_BOOTSTRAP_SERVERS: $env:DOTNET_KAFKA_BOOTSTRAP_SERVERS"

      - name: Health Check Loop
        env:
          DOTNET_ENVIRONMENT: "Development" # Helps Aspire resolve services if it has multiple modes
          # DOTNET_REDIS_URL and DOTNET_KAFKA_BOOTSTRAP_SERVERS are set by the port discovery script
          SIMULATOR_NUM_MESSAGES: ${{ env.SIMULATOR_NUM_MESSAGES_CI }}
          SIMULATOR_REDIS_KEY_GLOBAL_SEQUENCE: "flinkdotnet:global_sequence_id"
          SIMULATOR_REDIS_KEY_SINK_COUNTER: "flinkdotnet:sample:processed_message_counter"
          SIMULATOR_KAFKA_TOPIC: "flinkdotnet.sample.topic"
          SIMULATOR_REDIS_PASSWORD: "FlinkDotNet_Redis_CI_Password_2024"
        run: |
          $maxAttempts = 5  # Increased attempts for CI reliability
          $delaySeconds = 10  # Adequate delay for CI environment
          $verifierDll = "./FlinkDotNetAspire/IntegrationTestVerifier/bin/Release/net8.0/FlinkDotNet.IntegrationTestVerifier.dll"

          Write-Host "`n=== Health Check Configuration ===" 
          Write-Host "Max attempts: $maxAttempts"
          Write-Host "Delay between attempts: $delaySeconds seconds"
          Write-Host "Total max time: $($maxAttempts * $delaySeconds) seconds"
          Write-Host "Environment variables:"
          Write-Host "  DOTNET_REDIS_URL: $env:DOTNET_REDIS_URL"
          Write-Host "  DOTNET_KAFKA_BOOTSTRAP_SERVERS: $env:DOTNET_KAFKA_BOOTSTRAP_SERVERS"
          Write-Host "  SIMULATOR_NUM_MESSAGES: $env:SIMULATOR_NUM_MESSAGES"
          Write-Host "  SIMULATOR_REDIS_KEY_GLOBAL_SEQUENCE: $env:SIMULATOR_REDIS_KEY_GLOBAL_SEQUENCE"
          Write-Host "  SIMULATOR_REDIS_KEY_SINK_COUNTER: $env:SIMULATOR_REDIS_KEY_SINK_COUNTER"
          Write-Host "  SIMULATOR_KAFKA_TOPIC: $env:SIMULATOR_KAFKA_TOPIC"

          for ($attempt = 1; $attempt -le $maxAttempts; $attempt++) {
            Write-Host "`n--- Health check attempt $attempt/$maxAttempts ---"
            Write-Host "Starting health check at $(Get-Date -Format 'HH:mm:ss')..."
            
            & dotnet $verifierDll --health-check
            $healthExitCode = $LASTEXITCODE
            
            if ($healthExitCode -eq 0) {
              Write-Host "‚úÖ Health check PASSED on attempt $attempt" -ForegroundColor Green
              break
            }
            
            Write-Host "‚ùå Health check FAILED on attempt $attempt (exit code: $healthExitCode)" -ForegroundColor Red
            
            if ($attempt -lt $maxAttempts) {
              Write-Host "Waiting $delaySeconds seconds before retry..." -ForegroundColor Yellow
              Start-Sleep -Seconds $delaySeconds
            } else {
              Write-Host "‚ùå Max health check attempts ($maxAttempts) reached. Health checks failed." -ForegroundColor Red
              Write-Host "`n=== Final Diagnostics ==="
              Write-Host "AppHost process status:"
              if (Test-Path apphost.pid) {
                $apphostPid = Get-Content apphost.pid
                $process = Get-Process -Id $apphostPid -ErrorAction SilentlyContinue
                if ($process) {
                  Write-Host "  AppHost PID $apphostPid is still running"
                } else {
                  Write-Host "  AppHost PID $apphostPid is no longer running"
                }
              } else {
                Write-Host "  AppHost PID file not found"
              }
              exit 1
            }
          }

      - name: Diagnose FlinkJobSimulator Status
        env:
          DOTNET_ENVIRONMENT: "Development"
          SIMULATOR_NUM_MESSAGES: ${{ env.SIMULATOR_NUM_MESSAGES_CI }}
          SIMULATOR_REDIS_KEY_SINK_COUNTER: "flinkdotnet:sample:processed_message_counter"
        run: |
          Write-Host "üîç === DIAGNOSING FLINKJOBSIMULATOR STATUS ==="
          Write-Host "Checking if FlinkJobSimulator process is running..."
          
          # Check if AppHost is still running
          if (Test-Path apphost.pid) {
            $apphostPid = Get-Content apphost.pid
            $apphostProcess = Get-Process -Id $apphostPid -ErrorAction SilentlyContinue
            if ($apphostProcess) {
              Write-Host "‚úÖ AppHost (PID $apphostPid) is running"
            } else {
              Write-Host "‚ùå AppHost (PID $apphostPid) is not running"
            }
          } else {
            Write-Host "‚ùå AppHost PID file not found"
          }
          
          # Check for any FlinkJobSimulator processes (Aspire runs .NET projects as "dotnet <dll>")
          Write-Host "`nüîç Checking for FlinkJobSimulator processes..."
          
          # Get all dotnet processes and check their command lines for FlinkJobSimulator
          $allDotnetProcesses = Get-Process -Name "dotnet" -ErrorAction SilentlyContinue
          $flinkProcesses = @()
          
          if ($allDotnetProcesses) {
            Write-Host "Found $($allDotnetProcesses.Count) dotnet processes - checking command lines..."
            foreach ($proc in $allDotnetProcesses) {
              try {
                # Try to get command line using WMI for more detailed process info
                $wmiProcess = Get-WmiObject -Class Win32_Process -Filter "ProcessId = $($proc.Id)" -ErrorAction SilentlyContinue
                if ($wmiProcess -and $wmiProcess.CommandLine -like "*FlinkJobSimulator*") {
                  $flinkProcesses += [PSCustomObject]@{
                    PID = $proc.Id
                    Name = $proc.ProcessName
                    CommandLine = $wmiProcess.CommandLine
                  }
                  Write-Host "  Found FlinkJobSimulator: PID $($proc.Id), Command: $($wmiProcess.CommandLine)"
                }
              } catch {
                # Fallback: just check process name and basic info
                Write-Host "  PID $($proc.Id): Could not get command line (Access denied/WMI error)"
              }
            }
          }
          
          # Also check for any processes with FlinkJobSimulator in the name (direct execution)
          $directFlinkProcesses = Get-Process | Where-Object { $_.ProcessName -like "*FlinkJobSimulator*" } -ErrorAction SilentlyContinue
          if ($directFlinkProcesses) {
            foreach ($proc in $directFlinkProcesses) {
              $flinkProcesses += [PSCustomObject]@{
                PID = $proc.Id
                Name = $proc.ProcessName
                CommandLine = "Direct execution"
              }
              Write-Host "  Found direct FlinkJobSimulator: PID $($proc.Id), Name: $($proc.ProcessName)"
            }
          }
          
          if ($flinkProcesses.Count -gt 0) {
            Write-Host "‚úÖ Found FlinkJobSimulator processes:"
            $flinkProcesses | ForEach-Object { Write-Host "  PID: $($_.PID), Name: $($_.Name)" }
          } else {
            Write-Host "‚ùå No FlinkJobSimulator processes found"
            Write-Host "üîç Debugging: Listing all dotnet processes for analysis:"
            if ($allDotnetProcesses) {
              $allDotnetProcesses | ForEach-Object { 
                try {
                  $wmiProcess = Get-WmiObject -Class Win32_Process -Filter "ProcessId = $($_.Id)" -ErrorAction SilentlyContinue
                  if ($wmiProcess) {
                    Write-Host "    PID $($_.Id): $($wmiProcess.CommandLine)"
                  } else {
                    Write-Host "    PID $($_.Id): Command line not accessible"
                  }
                } catch {
                  Write-Host "    PID $($_.Id): WMI query failed"
                }
              }
            } else {
              Write-Host "    No dotnet processes found at all"
            }
          }
          
          # Check Docker containers for any Flink-related services
          Write-Host "`nüîç Checking Docker containers..."
          $containers = docker ps --format "{{.Names}}\t{{.Image}}\t{{.Status}}"
          Write-Host "Active containers:"
          $containers | ForEach-Object { Write-Host "  $_" }
          
          # Try to find any Aspire service logs and search for FlinkJobSimulator-specific content
          Write-Host "`nüîç Checking for Aspire service logs..."
          if (Test-Path apphost.out.log) {
            Write-Host "üìÑ Recent AppHost output log content:"
            $outputContent = Get-Content apphost.out.log -ErrorAction SilentlyContinue
            if ($outputContent) {
              # Look for FlinkJobSimulator-specific lines first
              $flinkLines = $outputContent | Where-Object { $_ -match "FlinkJobSimulator|FLINKJOBSIMULATOR|flinkjobsimulator" }
              if ($flinkLines) {
                Write-Host "üìç FlinkJobSimulator-related log entries:"
                $flinkLines | ForEach-Object { Write-Host "    FLINK: $_" }
              } else {
                Write-Host "üìç No FlinkJobSimulator-specific entries found in output log"
              }
              
              # Show general log content (last 50 lines)
              Write-Host "üìÑ General output log (last 50 lines):"
              $outputContent | Select-Object -Last 50 | ForEach-Object { Write-Host "  $_" }
            } else {
              Write-Host "üìÑ Output log file exists but is empty"
            }
          } else {
            Write-Host "üìÑ No apphost.out.log file found"
          }
          
          if (Test-Path apphost.err.log) {
            Write-Host "`nüìÑ Recent AppHost error log content:"
            $errorContent = Get-Content apphost.err.log -ErrorAction SilentlyContinue
            if ($errorContent) {
              # Look for FlinkJobSimulator-specific errors first
              $flinkErrors = $errorContent | Where-Object { $_ -match "FlinkJobSimulator|FLINKJOBSIMULATOR|flinkjobsimulator" }
              if ($flinkErrors) {
                Write-Host "üìç FlinkJobSimulator-related error entries:"
                $flinkErrors | ForEach-Object { Write-Host "    ERROR: $_" }
              } else {
                Write-Host "üìç No FlinkJobSimulator-specific errors found in error log"
              }
              
              # Show general error content (last 50 lines)
              Write-Host "üìÑ General error log (last 50 lines):"
              $errorContent | Select-Object -Last 50 | ForEach-Object { Write-Host "  $_" }
            } else {
              Write-Host "üìÑ Error log file exists but is empty"
            }
          } else {
            Write-Host "üìÑ No apphost.err.log file found"
          }
          
          # Additional diagnostic: Check if any project build outputs exist for FlinkJobSimulator
          Write-Host "`nüîç Checking FlinkJobSimulator build outputs..."
          $flinkSimulatorDll = "./FlinkDotNetAspire/FlinkJobSimulator/bin/Release/net8.0/FlinkJobSimulator.dll"
          if (Test-Path $flinkSimulatorDll) {
            $dllInfo = Get-Item $flinkSimulatorDll
            Write-Host "‚úÖ FlinkJobSimulator.dll exists: $flinkSimulatorDll"
            Write-Host "   Size: $($dllInfo.Length) bytes, Last Modified: $($dllInfo.LastWriteTime)"
          } else {
            Write-Host "‚ùå FlinkJobSimulator.dll not found at: $flinkSimulatorDll"
            Write-Host "   This could explain why AppHost cannot start FlinkJobSimulator"
          }

      - name: Wait for FlinkJobSimulator Completion
        env:
          DOTNET_ENVIRONMENT: "Development"
          SIMULATOR_NUM_MESSAGES: ${{ env.SIMULATOR_NUM_MESSAGES_CI }}
          SIMULATOR_REDIS_KEY_SINK_COUNTER: "flinkdotnet:sample:processed_message_counter"
        run: |
          Write-Host "üïê Waiting for FlinkJobSimulator to complete message processing..."
          Write-Host "Expected messages: ${{ env.SIMULATOR_NUM_MESSAGES_CI }}"
          Write-Host "Redis counter key: $env:SIMULATOR_REDIS_KEY_SINK_COUNTER"
          
          $maxWaitSeconds = 180  # 3 minutes max wait
          $checkIntervalSeconds = 5
          $expectedMessages = [int]"${{ env.SIMULATOR_NUM_MESSAGES_CI }}"
          $waitStartTime = Get-Date
          
          $completed = $false
          while (-not $completed -and ((Get-Date) - $waitStartTime).TotalSeconds -lt $maxWaitSeconds) {
            try {
              # Use redis-cli to check the counter value
              $redisCommand = "docker exec -i $(docker ps -q --filter 'ancestor=redis:latest' | Select-Object -First 1) redis-cli get `"$env:SIMULATOR_REDIS_KEY_SINK_COUNTER`""
              $counterValue = Invoke-Expression $redisCommand 2>$null
              
              if ($counterValue -match '^\d+$') {
                $currentCount = [int]$counterValue
                Write-Host "Current message count: $currentCount / $expectedMessages"
                
                if ($currentCount -ge $expectedMessages) {
                  Write-Host "‚úÖ FlinkJobSimulator completed! Messages processed: $currentCount"
                  $completed = $true
                } else {
                  $remainingSeconds = $maxWaitSeconds - ((Get-Date) - $waitStartTime).TotalSeconds
                  Write-Host "‚è≥ Waiting... (${remainingSeconds:F0}s remaining)"
                  Start-Sleep -Seconds $checkIntervalSeconds
                }
              } else {
                Write-Host "‚è≥ Waiting for job to start... (counter not yet initialized)"
                
                # Also check if there are any error markers in Redis
                try {
                  $errorCommand = "docker exec -i $(docker ps -q --filter 'ancestor=redis:latest' | Select-Object -First 1) redis-cli get `"flinkdotnet:job_execution_error`""
                  $errorValue = Invoke-Expression $errorCommand 2>$null
                  if ($errorValue -and $errorValue -ne "(nil)") {
                    Write-Host "‚ùå Found job execution error in Redis: $errorValue"
                    Write-Host "FlinkJobSimulator appears to have encountered an error during startup"
                    exit 1
                  }
                } catch {
                  # Ignore Redis error check failures
                }
                
                Start-Sleep -Seconds $checkIntervalSeconds
              }
            } catch {
              Write-Host "‚è≥ Waiting for Redis to be accessible... ($($_.Exception.Message))"
              Start-Sleep -Seconds $checkIntervalSeconds
            }
          }
          
          if (-not $completed) {
            Write-Host "‚ùå FlinkJobSimulator did not complete within $maxWaitSeconds seconds"
            Write-Host "Final diagnostic check..."
            
            # Final Redis check
            try {
              $redisCommand = "docker exec -i $(docker ps -q --filter 'ancestor=redis:latest' | Select-Object -First 1) redis-cli get `"$env:SIMULATOR_REDIS_KEY_SINK_COUNTER`""
              $finalCounterValue = Invoke-Expression $redisCommand 2>$null
              Write-Host "Final Redis counter value: $finalCounterValue"
              
              $errorCommand = "docker exec -i $(docker ps -q --filter 'ancestor=redis:latest' | Select-Object -First 1) redis-cli get `"flinkdotnet:job_execution_error`""
              $finalErrorValue = Invoke-Expression $errorCommand 2>$null
              if ($finalErrorValue -and $finalErrorValue -ne "(nil)") {
                Write-Host "Final error marker: $finalErrorValue"
              }
            } catch {
              Write-Host "Could not perform final Redis check: $($_.Exception.Message)"
            }
            
            Write-Host "Attempting to run FlinkJobSimulator directly as a fallback..."
            
            # Try to run FlinkJobSimulator directly to test if it can work independently
            try {
              Write-Host "Setting up environment for direct FlinkJobSimulator execution..."
              
              # Set up connection strings for direct execution
              $redisPort = $env:DOTNET_REDIS_PORT
              $kafkaPort = $env:DOTNET_KAFKA_PORT
              if ($redisPort -and $kafkaPort) {
                $env:ConnectionStrings__redis = "localhost:$redisPort"
                $env:ConnectionStrings__kafka = "localhost:$kafkaPort"
                
                Write-Host "Environment setup:"
                Write-Host "  ConnectionStrings__redis: $env:ConnectionStrings__redis"
                Write-Host "  ConnectionStrings__kafka: $env:ConnectionStrings__kafka"
                Write-Host "  SIMULATOR_NUM_MESSAGES: $env:SIMULATOR_NUM_MESSAGES"
                
                Write-Host "Starting FlinkJobSimulator directly..."
                $directArgs = @(
                  './FlinkDotNetAspire/FlinkJobSimulator/bin/Release/net8.0/FlinkJobSimulator.dll'
                )
                
                # Run directly with timeout
                $directProcess = Start-Process -FilePath 'dotnet' -ArgumentList $directArgs -NoNewWindow -PassThru
                Write-Host "Direct FlinkJobSimulator started with PID: $($directProcess.Id)"
                
                # Wait for direct execution to complete (shorter timeout)
                $directWaitSeconds = 60
                $directCompleted = $directProcess.WaitForExit($directWaitSeconds * 1000)
                
                if ($directCompleted) {
                  Write-Host "‚úÖ Direct FlinkJobSimulator execution completed"
                  
                  # Check if it actually processed messages
                  $directCheckCommand = "docker exec -i $(docker ps -q --filter 'ancestor=redis:latest' | Select-Object -First 1) redis-cli get `"$env:SIMULATOR_REDIS_KEY_SINK_COUNTER`""
                  $directCounterValue = Invoke-Expression $directCheckCommand 2>$null
                  if ($directCounterValue -match '^\d+$' -and [int]$directCounterValue -gt 0) {
                    Write-Host "‚úÖ Direct execution succeeded! Messages processed: $directCounterValue"
                    return  # Success, exit this script
                  } else {
                    Write-Host "‚ùå Direct execution completed but no messages were processed"
                  }
                } else {
                  Write-Host "‚ùå Direct FlinkJobSimulator execution timed out after $directWaitSeconds seconds"
                  if (-not $directProcess.HasExited) {
                    $directProcess.Kill()
                    Write-Host "Killed direct FlinkJobSimulator process"
                  }
                }
              } else {
                Write-Host "‚ùå Could not get Redis/Kafka ports for direct execution"
              }
            } catch {
              Write-Host "‚ùå Direct FlinkJobSimulator execution failed: $($_.Exception.Message)"
            }
            
            exit 1
          }

      - name: Run Verification Tests
        env:
          # SIMULATOR_NUM_MESSAGES needs to be the same as used by the job simulator.
          SIMULATOR_NUM_MESSAGES: ${{ env.SIMULATOR_NUM_MESSAGES_CI }}
          DOTNET_ENVIRONMENT: "Development"
          # DOTNET_REDIS_URL and DOTNET_KAFKA_BOOTSTRAP_SERVERS are set by the port discovery script
          MAX_ALLOWED_TIME_MS: ${{ env.MAX_ALLOWED_TIME_MS }}
          # These environment variables must match those set in AppHost for FlinkJobSimulator
          SIMULATOR_REDIS_KEY_GLOBAL_SEQUENCE: "flinkdotnet:global_sequence_id"
          SIMULATOR_REDIS_KEY_SINK_COUNTER: "flinkdotnet:sample:processed_message_counter"
          SIMULATOR_KAFKA_TOPIC: "flinkdotnet.sample.topic"
          SIMULATOR_REDIS_PASSWORD: "FlinkDotNet_Redis_CI_Password_2024"
        run: |
          # Check if AppHost is still running
          if (Test-Path apphost.pid) {
            $apphostPid = Get-Content apphost.pid
            $process = Get-Process -Id $apphostPid -ErrorAction SilentlyContinue
            if (-not $process) {
              Write-Host "ERROR: AppHost process (PID $apphostPid) is not running!"
              exit 1
            }
            Write-Host "AppHost process (PID $apphostPid) is running."
          } else {
            Write-Host "ERROR: AppHost PID file not found!"
            exit 1
          }

          echo "Running verification tests with SIMULATOR_NUM_MESSAGES=${{ env.SIMULATOR_NUM_MESSAGES_CI }}..."
          Write-Host "Environment variables:"
          Write-Host "  DOTNET_REDIS_URL: $env:DOTNET_REDIS_URL"
          Write-Host "  DOTNET_KAFKA_BOOTSTRAP_SERVERS: $env:DOTNET_KAFKA_BOOTSTRAP_SERVERS"
          Write-Host "  SIMULATOR_NUM_MESSAGES: $env:SIMULATOR_NUM_MESSAGES"
          Write-Host "  SIMULATOR_REDIS_KEY_GLOBAL_SEQUENCE: $env:SIMULATOR_REDIS_KEY_GLOBAL_SEQUENCE"
          Write-Host "  SIMULATOR_REDIS_KEY_SINK_COUNTER: $env:SIMULATOR_REDIS_KEY_SINK_COUNTER"
          Write-Host "  SIMULATOR_KAFKA_TOPIC: $env:SIMULATOR_KAFKA_TOPIC"
          $verifierDll = "./FlinkDotNetAspire/IntegrationTestVerifier/bin/Release/net8.0/FlinkDotNet.IntegrationTestVerifier.dll"
          & dotnet $verifierDll
          if ($LASTEXITCODE -ne 0) {
            echo "Verification tests FAILED."
            exit 1
          }
          echo "Verification tests PASSED."

      - name: Stop Aspire AppHost
        if: always()
        run: |
          Write-Host "=================== STOPPING APPHOST ==================="
          
          # Stop background monitor jobs first
          if (Test-Path apphost.output.job) {
            $outputJobId = Get-Content apphost.output.job
            Write-Host "Stopping output monitor job: $outputJobId"
            $outputJob = Get-Job -Id $outputJobId -ErrorAction SilentlyContinue
            if ($outputJob) {
              Write-Host "Output job state: $($outputJob.State)"
              Stop-Job -Id $outputJobId -ErrorAction SilentlyContinue
              Wait-Job -Id $outputJobId -Timeout 3 -ErrorAction SilentlyContinue
              Remove-Job -Id $outputJobId -ErrorAction SilentlyContinue
            }
          }
          
          if (Test-Path apphost.error.job) {
            $errorJobId = Get-Content apphost.error.job
            Write-Host "Stopping error monitor job: $errorJobId"
            $errorJob = Get-Job -Id $errorJobId -ErrorAction SilentlyContinue
            if ($errorJob) {
              Write-Host "Error job state: $($errorJob.State)"
              Stop-Job -Id $errorJobId -ErrorAction SilentlyContinue
              Wait-Job -Id $errorJobId -Timeout 3 -ErrorAction SilentlyContinue
              Remove-Job -Id $errorJobId -ErrorAction SilentlyContinue
            }
          }
          
          # Wait for final log writes
          Write-Host "Waiting for final log writes..."
          Start-Sleep -Seconds 2
          
          # Stop AppHost process
          if (Test-Path apphost.pid) {
            $apphostPid = Get-Content apphost.pid
            Write-Host "Stopping AppHost with PID $apphostPid"
            
            $process = Get-Process -Id $apphostPid -ErrorAction SilentlyContinue
            if ($process) {
              Write-Host "Process is running, stopping it..."
              Stop-Process -Id $apphostPid -Force -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 2
            } else {
              Write-Host "Process was already stopped."
            }
            
            Write-Host "apphost.pid content after stopping:"
            Get-Content apphost.pid
          } else {
            Write-Host "No AppHost PID file found."
          }
          
          # Give file system time to sync
          Start-Sleep -Seconds 1
          
          Write-Host "=================== APPHOST OUTPUT LOG ==================="
          if (Test-Path apphost.out.log) {
            $outSize = (Get-Item apphost.out.log).Length
            Write-Host "apphost.out.log size: $outSize bytes"
            
            if ($outSize -gt 0) {
              Write-Host "Reading apphost.out.log content:"
              try {
                $lines = Get-Content apphost.out.log -ErrorAction SilentlyContinue
                if ($lines -and $lines.Count -gt 0) {
                  $lines | ForEach-Object { 
                    if ($_ -and $_.Trim()) { 
                      Write-Host $_ 
                    }
                  }
                  Write-Host "Total lines read: $($lines.Count)"
                } else {
                  Write-Host "No content lines found in apphost.out.log"
                }
              } catch {
                Write-Host "Error reading apphost.out.log: $_"
              }
            } else {
              Write-Host "apphost.out.log exists but is empty"
            }
          } else {
            Write-Host "No apphost.out.log found"
          }
          
          Write-Host "=================== APPHOST ERROR LOG ==================="
          if (Test-Path apphost.err.log) {
            $errSize = (Get-Item apphost.err.log).Length
            Write-Host "apphost.err.log size: $errSize bytes"
            
            if ($errSize -gt 0) {
              Write-Host "Reading apphost.err.log content:"
              try {
                $lines = Get-Content apphost.err.log -ErrorAction SilentlyContinue
                if ($lines -and $lines.Count -gt 0) {
                  $lines | ForEach-Object { 
                    if ($_ -and $_.Trim()) { 
                      Write-Host $_ 
                    }
                  }
                  Write-Host "Total lines read: $($lines.Count)"
                } else {
                  Write-Host "No content lines found in apphost.err.log"
                }
              } catch {
                Write-Host "Error reading apphost.err.log: $_"
              }
            } else {
              Write-Host "apphost.err.log exists but is empty"
            }
          } else {
            Write-Host "No apphost.err.log found"
          }
          
          Write-Host "=================== DEBUG INFO ==================="
          Write-Host "Current directory files:"
          Get-ChildItem -Filter "apphost*" | ForEach-Object {
            Write-Host "  $($_.Name) - Size: $($_.Length) bytes, LastWrite: $($_.LastWriteTime)"
          }
          
          Write-Host "AppHost cleanup complete."
